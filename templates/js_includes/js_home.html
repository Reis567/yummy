<script>

// Função para mostrar mensagens toast
function showMessage(type, message, isCompact = false) {
    console.log('DEBUG: showMessage chamada', {type, message, isCompact});
    const alertClass = isCompact ? 'alert-compact' : '';
    const alertHtml = `
        <div class="alert alert-${type} alert-dismissible fade show ${alertClass}" role="alert">
            ${message}
        </div>
    `;
    
    if (isCompact) {
        // Remover alertas compactos existentes
        $('.alert-compact').remove();
        
        // Adicionar o novo alerta compacto ao final do body
        $('body').append(alertHtml);
    } else {
        // Inserir alerta no topo da página
        $('.page-title').before(alertHtml);
    }
    
    // Auto-remover após 3 segundos para mensagens compactas, 5 para as regulares
    setTimeout(function() {
        $('.alert' + (isCompact ? '.alert-compact' : '')).alert('close');
    }, isCompact ? 3000 : 5000);
}

// Atualiza a barra de progresso e porcentagem de itens concluídos
function atualizarProgressoLista(listaCard, concluido, itemId) {
    // Obter valores atuais para cálculo
    const infoText = listaCard.find('.text-muted.small');
    const textoAtual = infoText.text();
    const totalItens = parseInt(textoAtual.split('|')[0].trim().split(' ')[0]);
    let percentualAtual = parseInt(textoAtual.split('|')[1].trim().split('%')[0]);
    
    // Calcular nova porcentagem com base na ação (marcar/desmarcar)
    let novaPortcentagem;
    if (concluido) {
        // Se estamos marcando como concluído, incrementar a porcentagem
        novaPortcentagem = Math.min(100, percentualAtual + Math.round(100 / totalItens));
    } else {
        // Se estamos desmarcando como concluído, decrementar a porcentagem
        novaPortcentagem = Math.max(0, percentualAtual - Math.round(100 / totalItens));
    }
    
    // Atualizar texto de porcentagem
    infoText.text(`${totalItens} total | ${novaPortcentagem}% concluído`);
    
    // Selecionar e atualizar a barra de progresso
    const progressBar = listaCard.find('.progress-bar');
    
    // Atualização visual com animação
    progressBar.css('width', novaPortcentagem + '%');
    progressBar.attr('aria-valuenow', novaPortcentagem);
    
    // Adicionar classe de animação temporariamente
    progressBar.addClass('progress-bar-animated');
    setTimeout(function() {
        progressBar.removeClass('progress-bar-animated');
    }, 1000);
    
    // Se chegou a 100%, adicionar uma classe para mudar a cor
    if (novaPortcentagem >= 100) {
        progressBar.addClass('bg-success');
    } else {
        progressBar.removeClass('bg-success');
    }
    
    return novaPortcentagem;
}

// Remove um item da lista via API e atualiza a UI
function removerItem(itemId, element) {
    // Adicionar classe de animação de remoção
    $(element).addClass('removing-item');
    
    // Obter a lista-card pai para atualização posterior
    const listaCard = $(element).closest('.lista-card');
    
    // Fazer a chamada para a API de exclusão
    $.ajax({
        url: `/api/itens/${itemId}/excluir/`,
        type: 'POST',
        beforeSend: function(xhr) {
            xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
        },
        success: function(response) {
            // Após a animação, remover o elemento do DOM
            setTimeout(() => {
                $(element).remove();
                
                // Atualizar contagem de itens e progresso
                atualizarMetadadosLista(listaCard);
                
                // Mostrar mensagem de sucesso
                showMessage('success', 'Item removido com sucesso!', true);
            }, 500); // Corresponde à duração da animação
        },
        error: function(error) {
            console.error('DEBUG: Erro ao remover item', error);
            
            // Remover classe de animação em caso de erro
            $(element).removeClass('removing-item');
            
            // Mostrar mensagem de erro
            showMessage('danger', 'Erro ao remover o item. Tente novamente.', true);
        }
    });
}

// Atualiza os metadados da lista após alterações
function atualizarMetadadosLista(listaCard) {
    // Contar total de itens
    const totalItens = listaCard.find('.lista-item').length;
    
    // Contar itens concluídos
    const itensConcluidos = listaCard.find('.lista-item.concluido').length;
    
    // Calcular porcentagem concluída
    let porcentagem = 0;
    if (totalItens > 0) {
        porcentagem = Math.round((itensConcluidos / totalItens) * 100);
    }
    
    // Atualizar texto de contagem e porcentagem
    listaCard.find('.text-muted.small').text(`${totalItens} total | ${porcentagem}% concluído`);
    
    // Atualizar barra de progresso
    const progressBar = listaCard.find('.progress-bar');
    progressBar.css('width', porcentagem + '%');
    progressBar.attr('aria-valuenow', porcentagem);
    
    // Adicionar classe de animação
    progressBar.addClass('progress-bar-animated');
    setTimeout(function() {
        progressBar.removeClass('progress-bar-animated');
    }, 1000);
    
    // Se não houver itens, mostrar mensagem "Esta lista ainda não tem itens"
    if (totalItens === 0) {
        const listaCardBody = listaCard.find('.lista-card-body');
        const listaItens = listaCardBody.find('.lista-itens');
        
        listaItens.remove();
        
        const listaId = listaCard.find('[data-lista-id]').first().data('lista-id');
        
        listaCardBody.append(`
            <div class="text-center py-3">
                <p class="text-muted mb-2">Esta lista ainda não tem itens.</p>
                <button class="btn btn-sm btn-outline-primary add-item" data-lista-id="${listaId}">
                    <i class="fas fa-plus me-1"></i> Adicionar Item
                </button>
            </div>
        `);
        
        // Adicionar event listener ao novo botão
        listaCardBody.find('.add-item').on('click', function(e) {
            e.preventDefault();
            const listaId = $(this).data('lista-id');
            const listaNome = $(this).closest('.lista-card').find('.lista-title').text().trim();
            
            // Preencher o ID da lista no formulário e atualizar o título do modal
            $('#id_item_lista').val(listaId);
            $('#modalNovoItemLabel').html(`<i class="fas fa-plus-circle me-2"></i>Novo Item em "${listaNome}"`);
            
            // Resetar o formulário
            $('#formNovoItem').trigger('reset');
            
            // Mostrar o modal
            $('#modalNovoItem').modal('show');
        });
    }
    
    // Atualizar contadores de prioridade
    atualizarContadoresPrioridade(listaCard);
}

// Atualiza os contadores de prioridade de itens
function atualizarContadoresPrioridade(listaCard) {
    // Contar itens por prioridade
    const itensAlta = listaCard.find('.lista-item.alta').length;
    const itensMedia = listaCard.find('.lista-item.media').length;
    const itensBaixa = listaCard.find('.lista-item.baixa').length;
    
    // Atualizar ou remover contador de alta prioridade
    atualizarContadorPrioridade(listaCard, 'alta', itensAlta, 'Itens de prioridade alta', 'fa-arrow-up', 'text-danger');
    
    // Atualizar ou remover contador de média prioridade
    atualizarContadorPrioridade(listaCard, 'media', itensMedia, 'Itens de prioridade média', 'fa-equals', 'text-warning');
    
    // Atualizar ou remover contador de baixa prioridade
    atualizarContadorPrioridade(listaCard, 'baixa', itensBaixa, 'Itens de prioridade baixa', 'fa-arrow-down', 'text-success');
}

// Função auxiliar para atualizar um contador de prioridade específico
function atualizarContadorPrioridade(listaCard, prioridade, quantidade, titulo, icone, corClass) {
    const elementoContador = listaCard.find(`.lista-card-footer span[title="${titulo}"]`);
    
    if (quantidade > 0) {
        if (elementoContador.length === 0) {
            // Criar contador se não existir
            listaCard.find('.d-flex.flex-wrap.gap-2').append(`
                <span title="${titulo}">
                    <i class="fas ${icone} ${corClass} me-1"></i>${quantidade}
                </span>
            `);
        } else {
            // Atualizar contador existente
            elementoContador.html(`<i class="fas ${icone} ${corClass} me-1"></i>${quantidade}`);
        }
    } else if (elementoContador.length > 0) {
        // Remover contador se quantidade for zero
        elementoContador.remove();
    }
}

// Adicione essa função ao seu arquivo JavaScript (paste-2.txt)
function aplicarCorPersonalizada(listaCard) {
    // Se recebemos um objeto jQuery, usamos [0] para obter o elemento DOM
    const listaElement = listaCard instanceof jQuery ? listaCard[0] : listaCard;
    
    // Obter a cor personalizada do dataset
    const corPersonalizada = listaElement.dataset.cor || $(listaElement).data('cor');
    
    if (!corPersonalizada) return; // Se não houver cor definida, usar os estilos padrão
    
    // Aplicar a cor ao marcador superior (via propriedade CSS customizada)
    $(listaElement).find('.lista-card-header').css('--primary-color', corPersonalizada);
    
    // Aplicar a cor ao ícone
    $(listaElement).find('.lista-icon').css('background-color', corPersonalizada);
    
    // Aplicar a cor aos botões de ação
    const botoesAcao = $(listaElement).find('.btn-lista-action');
    if (botoesAcao.length) {
        // Criar um gradiente baseado na cor personalizada
        const corEscura = adjustColor(corPersonalizada, -20);
        botoesAcao.css('background', `linear-gradient(135deg, ${corPersonalizada}, ${corEscura})`);
    }
    
    // Aplicar a cor à barra de progresso
    $(listaElement).find('.progress-bar').css('background-color', corPersonalizada);
}

// Função auxiliar para ajustar cor (escurecer/clarear)
function adjustColor(hex, percent) {
    // Remover o # se existir
    hex = hex.replace('#', '');
    
    // Converter para RGB
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);
    
    // Ajustar valores
    r = Math.max(0, Math.min(255, r + percent));
    g = Math.max(0, Math.min(255, g + percent));
    b = Math.max(0, Math.min(255, b + percent));
    
    // Converter de volta para hex
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// Atualiza estatísticas do dashboard sem recarregar a página
function atualizarDashboardStatsLocalmente() {
    // Contar totais das listas
    const totalListas = $('.lista-card').length;
    const listasEmAndamento = $('.lista-card.em_andamento').length;
    const listasConcluidas = $('.lista-card.concluida').length;
    
    // Atualizar os contadores no dashboard
    $('.dashboard-card:eq(0) .stat-number').text(totalListas);
    $('.dashboard-card:eq(1) .stat-number').text(listasEmAndamento);
    $('.dashboard-card:eq(2) .stat-number').text(listasConcluidas);
}

// Adapta a interface para dispositivos móveis
function adjustForMobile() {
    // Se a largura da tela for menor que 576px (dispositivos muito pequenos)
    if (window.innerWidth < 576) {
        // Reduzir o número de itens mostrados em cada lista
        $('.lista-itens').each(function() {
            const items = $(this).find('.lista-item');
            items.each(function(index) {
                if (index > 1) { // Mostrar apenas os 2 primeiros itens em telas muito pequenas
                    $(this).hide();
                }
            });
            
            // Mostrar o botão "Ver todos" para listas com mais de 2 itens
            if (items.length > 2) {
                // Se o botão "Ver todos" já não existir, adicione-o
                if ($(this).find('.btn-view-all').length === 0) {
                    const listaId = $(this).closest('.lista-card').find('[data-lista-id]').first().data('lista-id');
                    const totalItems = items.length;
                    $(this).append(`
                        <div class="text-center mt-2">
                            <a href="#" class="btn btn-sm btn-outline-primary view-lista btn-view-all" data-lista-id="${listaId}">
                                Ver todos os ${totalItems} itens
                            </a>
                        </div>
                    `);
                }
            }
        });
    } else {
        // Em telas maiores, mostrar até 3 itens conforme o design original
        $('.lista-item').show();
        $('.btn-view-all').parent().remove();
    }
}

// Funções auxiliares para normalização de dados
function getPrioridadeDisplay(prioridade) {
    switch (prioridade) {
        case 'alta': return 'Alta';
        case 'media': return 'Média';
        case 'baixa': return 'Baixa';
        default: return 'Média';
    }
}

function getStatusDisplay(status) {
    switch (status) {
        case 'pendente': return 'Pendente';
        case 'em_andamento': return 'Em andamento';
        case 'concluido': return 'Concluído';
        case 'adiado': return 'Adiado';
        case 'cancelado': return 'Cancelado';
        default: return 'Pendente';
    }
}

// Função para adicionar um novo item à UI
window.adicionarNovoItemNaUI = function(listaCard, item) {
    // Normalizar os dados de resposta para os valores esperados
    item = {
        id: item.id || 0,
        nome: item.nome,
        descricao: item.descricao || '',
        prioridade: item.prioridade || 'media',
        status: item.status || 'pendente',
        data_hora: item.data_hora,
        lista_id: item.lista_id || item.lista,
        prioridade_display: item.prioridade_display || getPrioridadeDisplay(item.prioridade),
        status_display: item.status_display || getStatusDisplay(item.status),
        tempo_restante: item.tempo_restante || '',
        esta_atrasado: item.esta_atrasado || false,
        porcentagem_concluida_lista: item.porcentagem_concluida_lista || 0
    };

    // Criar HTML para o novo item
    const tempoRestante = item.tempo_restante || '';
    const estaAtrasado = item.esta_atrasado ? 'overdue' : '';
    const statusClass = item.status === 'concluido' ? 'concluido' : '';
    const checkedAttr = item.status === 'concluido' ? 'checked' : '';
    
    const itemHTML = `
        <div class="lista-item ${item.prioridade} ${statusClass} lista-item-new">
            <input type="checkbox" class="item-checkbox" ${checkedAttr} data-item-id="${item.id}">
            <div class="item-content">
                <span class="item-nome">${item.nome}</span>
                ${item.descricao ? `<p class="item-descricao">${item.descricao}</p>` : ''}
                <div class="item-meta">
                    <span class="item-badge badge-prioridade ${item.prioridade}">${item.prioridade_display}</span>
                    ${item.status !== 'concluido' ? `<span class="item-badge badge-status">${item.status_display}</span>` : ''}
                    ${item.data_hora ? `
                        <span class="item-deadline ${estaAtrasado}">
                            <i class="far ${estaAtrasado ? 'fa-clock' : 'fa-calendar-alt'} me-1"></i>
                            ${tempoRestante}
                        </span>
                    ` : ''}
                </div>
            </div>
            <button class="btn-remove-item" type="button" data-item-id="${item.id}" title="Remover item">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `;
    
    // Localizar onde inserir o novo item
    const listaItens = listaCard.find('.lista-itens');
    
    // Se não houver itens, remover a mensagem "nenhum item" e criar div para itens
    if (listaItens.length === 0) {
        // Remover a mensagem "Esta lista ainda não tem itens"
        const emptyState = listaCard.find('.lista-card-body .text-center');
        
        if (emptyState.length > 0) {
            emptyState.remove();
            
            // Criar a div para itens
            listaCard.find('.lista-card-body').append(`
                <div class="lista-itens">
                    ${itemHTML}
                </div>
            `);
        }
    } else {
        // Adicionar o item à lista existente
        listaItens.prepend(itemHTML);
        
        // Limitar a 3 itens visíveis
        const itens = listaItens.find('.lista-item');
        
        if (itens.length > 3) {
            // Se já existe um botão "Ver todos", apenas atualize o número
            const verTodosBtn = listaItens.find('.btn.view-lista');
            if (verTodosBtn.length > 0) {
                verTodosBtn.text(`Ver todos os ${itens.length} itens`);
            } else {
                // Esconder o item mais antigo e adicionar botão "Ver todos"
                itens.eq(3).hide();
                listaItens.append(`
                    <div class="text-center mt-2">
                        <a href="#" class="btn btn-sm btn-outline-primary view-lista" data-lista-id="${item.lista_id}">
                            Ver todos os ${itens.length} itens
                        </a>
                    </div>
                `);
                
                // Adicionar handler para o novo botão
                listaItens.find('.btn.view-lista').on('click', function(e) {
                    e.preventDefault();
                    const listaId = $(this).data('lista-id');
                    window.location.href = `/listas/${listaId}/`;
                });
            }
        }
    }
    
    // Atualizar a contagem de itens e a porcentagem
    const infoText = listaCard.find('.text-muted.small');
    const contagem = infoText.text().split('|')[0].trim();
    const totalItens = parseInt(contagem.split(' ')[0]) + 1;
    const porcentagemConcluida = item.porcentagem_concluida_lista || parseInt(infoText.text().split('|')[1].trim().split('%')[0]);
    infoText.text(`${totalItens} total | ${porcentagemConcluida}% concluído`);
    
    // Atualizar a barra de progresso com animação
    const progressBar = listaCard.find('.progress-bar');
    progressBar.css('width', porcentagemConcluida + '%');
    progressBar.attr('aria-valuenow', porcentagemConcluida);
    
    // Adicionar classe de animação
    progressBar.addClass('progress-bar-animated');
    setTimeout(function() {
        progressBar.removeClass('progress-bar-animated');
    }, 1000);
    
    // Atualizar contadores de prioridade
    const prioridadeAjustada = item.prioridade === 'alta' ? 'alta' : 
                              item.prioridade === 'media' ? 'media' : 'baixa';
    
    // Encontrar o contador específico
    const contadorSelector = prioridadeAjustada === 'alta' ? 'Itens de prioridade alta' :
                           prioridadeAjustada === 'media' ? 'Itens de prioridade média' : 'Itens de prioridade baixa';
    
    const contadorAtual = listaCard.find(`.lista-card-footer span[title="${contadorSelector}"]`);
    
    if (contadorAtual.length > 0) {
        // Atualizar contador existente
        const valorAtual = parseInt(contadorAtual.text().trim());
        contadorAtual.html(`<i class="fas fa-${prioridadeAjustada === 'alta' ? 'arrow-up' : prioridadeAjustada === 'media' ? 'equals' : 'arrow-down'} text-${prioridadeAjustada === 'alta' ? 'danger' : prioridadeAjustada === 'media' ? 'warning' : 'success'} me-1"></i>${valorAtual + 1}`);
    } else {
        // Criar novo contador
        const novoContador = $(`<span title="${contadorSelector}"><i class="fas fa-${prioridadeAjustada === 'alta' ? 'arrow-up' : prioridadeAjustada === 'media' ? 'equals' : 'arrow-down'} text-${prioridadeAjustada === 'alta' ? 'danger' : prioridadeAjustada === 'media' ? 'warning' : 'success'} me-1"></i>1</span>`);
        listaCard.find('.d-flex.flex-wrap.gap-2').append(novoContador);
    }
    
    // Adicionar handler do checkbox ao novo item
    const novoItem = listaCard.find(`.lista-item-new`);
    novoItem.find('.item-checkbox').off('change').on('change', function() {
        const itemId = $(this).data('item-id');
        const concluido = $(this).prop('checked');
        const novoStatus = concluido ? 'concluido' : 'pendente';
        const itemElement = $(this).closest('.lista-item');
        const listaCard = itemElement.closest('.lista-card');
        
        // Atualizar a classe do item imediatamente para feedback visual
        if (concluido) {
            itemElement.addClass('concluido');
        } else {
            itemElement.removeClass('concluido');
        }
        
        // Atualizar barra de progresso imediatamente para feedback visual
        const novaPortcentagem = atualizarProgressoLista(listaCard, concluido, itemId);
        
        // Enviar para a API
        $.ajax({
            url: `/api/itens/${itemId}/status/`,
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ status: novoStatus }),
            beforeSend: function(xhr) {
                xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
            },
            success: function(response) {
                // Mostrar mensagem de sucesso discretamente
                showMessage('success', 'Item atualizado!', true);
            },
            error: function(error) {
                console.error('DEBUG: Erro ao atualizar status do item novo', error);
                // Reverter a mudança no checkbox e na classe em caso de erro
                itemElement.find('.item-checkbox').prop('checked', !concluido);
                if (concluido) {
                    itemElement.removeClass('concluido');
                } else {
                    itemElement.addClass('concluido');
                }
                
                // Reverter a barra de progresso
                atualizarProgressoLista(listaCard, !concluido, itemId);
                
                showMessage('danger', 'Erro ao atualizar status do item.', true);
            }
        });
    });
    
    // Adicionar handler para o botão de remover
    novoItem.find('.btn-remove-item').on('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const itemId = $(this).data('item-id');
        const itemElement = $(this).closest('.lista-item');
        const itemNome = itemElement.find('.item-nome').text().trim();
        
        // Confirmar antes de remover
        if (confirm(`Tem certeza que deseja remover o item "${itemNome}"?`)) {
            removerItem(itemId, itemElement);
        }
    });
    
    // Remover a classe lista-item-new após a animação
    setTimeout(function() {
        novoItem.removeClass('lista-item-new');
    }, 2000);
    
    // Atualizar estatísticas do dashboard localmente
    atualizarDashboardStatsLocalmente();
};

/**
 * Inicialização da página
 */
$(document).ready(function() {
    /**
     * Funcionalidades de Swipe para Mobile
     */
    // Variáveis para controle de toque
    let touchStartX = 0;
    let touchEndX = 0;
    let currentItem = null;
    let swipeThreshold = 70; // Limiar para considerar um swipe válido
    let maxSwipeLeft = 100; // Movimento máximo para esquerda
    let maxSwipeRight = 60; // Movimento máximo para direita
    let animationInProgress = false;
    
    // Touch start event
    $(document).on('touchstart', '.lista-item', function(e) {
        if (animationInProgress) return;
        
        touchStartX = e.originalEvent.touches[0].clientX;
        currentItem = $(this);
        
        // Remover qualquer overlay existente
        $('.swipe-overlay').remove();
        // Resetar transformação
        $(this).css('transform', '');
        
        // Inicializar o elemento para animações suaves
        $(this).addClass('swiping');
    });
    
    // Touch move event
    $(document).on('touchmove', '.lista-item', function(e) {
        if (!currentItem || animationInProgress) return;
        
        const currentX = e.originalEvent.touches[0].clientX;
        const diffX = currentX - touchStartX;
        
        // Se estiver deslizando
        if (Math.abs(diffX) > 10) {
            e.preventDefault(); // Impedir o scroll vertical durante o swipe
            
            // Limitar o movimento
            let translateX;
            
            if (diffX < 0) {
                // Swipe para esquerda (excluir) - limitar movimento máximo
                translateX = Math.max(diffX, -maxSwipeLeft);
                
                // Criar indicador de exclusão se não existir
                if ($(this).find('.swipe-overlay.delete').length === 0) {
                    $(this).append('<div class="swipe-overlay delete"><i class="fas fa-trash-alt"></i></div>');
                }
                
                // Ajustar opacidade do indicador de exclusão
                const opacity = Math.min(0.9, Math.abs(diffX) / 100);
                $(this).find('.swipe-overlay.delete').css('opacity', opacity);
                
                // Remover indicador de conclusão se existir
                $(this).find('.swipe-overlay.complete').remove();
            } else {
                // Swipe para direita (concluir) - limitar movimento máximo
                translateX = Math.min(diffX, maxSwipeRight);
                
                // Criar indicador de conclusão se não existir
                if ($(this).find('.swipe-overlay.complete').length === 0) {
                    $(this).append('<div class="swipe-overlay complete"><i class="fas fa-check"></i></div>');
                }
                
                // Ajustar opacidade do indicador de conclusão
                const opacity = Math.min(0.9, Math.abs(diffX) / 80);
                $(this).find('.swipe-overlay.complete').css('opacity', opacity);
                
                // Remover indicador de exclusão se existir
                $(this).find('.swipe-overlay.delete').remove();
            }
            
            // Aplicar transformação com efeito de resistência
            $(this).css('transform', `translateX(${translateX}px)`);
            
            // Alterar cor de fundo baseado na direção e progresso
            if (diffX < 0) {
                // Vermelho para exclusão (mais intenso conforme progride)
                const redIntensity = Math.min(15, Math.abs(diffX) / 10);
                $(this).css('background-color', `rgba(255, 100, 100, 0.${Math.floor(redIntensity)})`);
            } else {
                // Verde para marcar como concluído
                const greenIntensity = Math.min(15, Math.abs(diffX) / 8);
                $(this).css('background-color', `rgba(100, 255, 100, 0.${Math.floor(greenIntensity)})`);
            }
        }
    });
    
    // Touch end event
    $(document).on('touchend', '.lista-item', function(e) {
        if (!currentItem || animationInProgress) return;
        
        touchEndX = e.originalEvent.changedTouches[0].clientX;
        const diffX = touchEndX - touchStartX;
        const swipeDistance = Math.abs(diffX);
        
        // Remover classe de swiping
        $(this).removeClass('swiping');
        
        // Remover background temporário
        $(this).css('background-color', '');
        
        if (swipeDistance > swipeThreshold) {
            // Ação baseada na direção do swipe
            if (diffX < 0) {
                // Swipe para esquerda - Excluir
                mostrarConfirmacaoExclusao($(this));
            } else {
                // Swipe para direita - Marcar como concluído/pendente
                toggleItemConcluido($(this));
            }
        } else {
            // Swipe não foi suficiente, retornar à posição original
            resetSwipe($(this));
        }
        
        currentItem = null;
    });
    
    // Touch cancel event
    $(document).on('touchcancel', '.lista-item', function(e) {
        if (!currentItem) return;
        
        // Retornar à posição original
        resetSwipe($(this));
        
        // Resetar variáveis
        currentItem = null;
    });
    
    // Função para resetar o swipe
    function resetSwipe(item) {

        item.css('transition', 'transform 0.3s ease-out, background-color 0.3s ease-out');
        item.css('transform', '');
        item.css('background-color', '');
        
        // Remover overlay após a animação
        setTimeout(function() {
            item.find('.swipe-overlay').remove();
            item.css('transition', '');
        }, 300);
    }
    
    // Função para mostrar confirmação de exclusão aprimorada
    function mostrarConfirmacaoExclusao(item) {
        animationInProgress = true;
        
        // Identificar o item e buscar dados necessários
        const itemId = item.find('.item-checkbox').data('item-id');
        const itemNome = item.find('.item-nome').text().trim();
        
        // Manter o item deslocado e realçar o overlay
        item.css({
            'transform': `translateX(-${maxSwipeLeft}px)`,
            'transition': 'transform 0.2s ease-out'
        });
        
        // Atualizar overlay de exclusão para ficar mais visível
        item.find('.swipe-overlay.delete').css({
            'opacity': '1',
            'width': '100px'
        });
        
        // Criar toast de confirmação
        const toastHTML = `
            <div class="toast-confirm" id="toast-delete-${itemId}">
                <div class="toast-message">
                    <span>Excluir "${itemNome.length > 15 ? itemNome.substring(0, 15) + '...' : itemNome}"?</span>
                </div>
                <div class="toast-actions">
                    <button class="btn-toast-cancel" data-action="cancel">Cancelar</button>
                    <button class="btn-toast-confirm" data-action="confirm" data-item-id="${itemId}">Excluir</button>
                </div>
            </div>
        `;
        
        // Remover toasts anteriores
        $('.toast-confirm').remove();
        
        // Adicionar a nova toast
        $('body').append(toastHTML);
        
        // Animar entrada do toast
        const toast = $(`#toast-delete-${itemId}`);
        setTimeout(() => toast.addClass('show'), 10);
        
        // Handler para cancelar
        toast.find('.btn-toast-cancel').on('click', function() {
            // Esconder toast
            toast.removeClass('show');
            setTimeout(function() {
                toast.remove();
                // Resetar item
                resetSwipe(item);
                animationInProgress = false;
            }, 300);
        });
        
        // Handler para confirmar
        toast.find('.btn-toast-confirm').on('click', function() {
            const itemId = $(this).data('item-id');
            
            // Esconder toast
            toast.removeClass('show');
            setTimeout(() => toast.remove(), 300);
            
            // Animar exclusão do item
            item.addClass('removing-item');
            
            // Chamar função de exclusão
            removerItem(itemId, item);
            
            // Resetar flag após completar a animação
            setTimeout(() => {
                animationInProgress = false;
            }, 500);
        });
        
        // Auto-remover após 5 segundos se não houver interação
        setTimeout(function() {
            if (toast.length) {
                toast.removeClass('show');
                setTimeout(function() {
                    toast.remove();
                    resetSwipe(item);
                    animationInProgress = false;
                }, 300);
            }
        }, 5000);
    }
    
    // Função para alternar o estado concluído do item
    function toggleItemConcluido(item) {
        animationInProgress = true;
        
        // Identificar o item e seu estado atual
        const checkbox = item.find('.item-checkbox');
        const itemId = checkbox.data('item-id');
        const concluido = !checkbox.prop('checked'); // Inverter o estado atual
        
        // Animar o item deslocando totalmente para a direita e depois voltando
        item.css({
            'transform': `translateX(${maxSwipeRight * 1.5}px)`,
            'transition': 'transform 0.2s ease-out, background-color 0.2s ease-out'
        });
        
        // Aplicar uma cor de fundo visual temporária
        item.css('background-color', concluido ? 'rgba(100, 255, 100, 0.2)' : 'rgba(255, 255, 255, 1)');
        
        // Atualizar overlay para ficar mais visível
        item.find('.swipe-overlay.complete').css({
            'opacity': '1',
            'width': '60px'
        });
        
        // Esperar um momento antes de começar a ação
        setTimeout(function() {
            // Marcar/desmarcar o checkbox
            checkbox.prop('checked', concluido);
            
            // Atualizar classes visuais
            if (concluido) {
                item.addClass('concluido');
            } else {
                item.removeClass('concluido');
            }
            
            // Obter a lista-card pai para atualização
            const listaCard = item.closest('.lista-card');
            
            // Atualizar barra de progresso
            const novaPortcentagem = atualizarProgressoLista(listaCard, concluido, itemId);
            
            // Preparar dados para API
            const novoStatus = concluido ? 'concluido' : 'pendente';
            
            // Animar o retorno à posição normal
            setTimeout(function() {
                item.css({
                    'transform': '',
                    'transition': 'transform 0.3s ease-out, background-color 0.3s ease-out'
                });
                
                // Remover overlay após a animação
                setTimeout(function() {
                    item.find('.swipe-overlay').remove();
                    item.css('transition', '');
                    animationInProgress = false;
                }, 300);
            }, 400);
            
            // Chamar API para salvar o novo status
            $.ajax({
                url: `/api/itens/${itemId}/status/`,
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ status: novoStatus }),
                beforeSend: function(xhr) {
                    xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
                },
                success: function(response) {
                    // Mostrar mensagem discreta de sucesso
                    const mensagem = concluido ? 'Item concluído!' : 'Item marcado como pendente!';
                    showMessage('success', mensagem, true);
                    
                    // Atualizar porcentagem se houver discrepância
                    if (response.item && response.item.lista && response.item.lista.porcentagem_concluida !== undefined) {
                        const porcentagemAPI = response.item.lista.porcentagem_concluida;
                        if (porcentagemAPI !== novaPortcentagem) {
                            // Atualizar texto e barra de progresso
                            const infoText = listaCard.find('.text-muted.small');
                            const textoAtual = infoText.text();
                            const totalItens = parseInt(textoAtual.split('|')[0].trim().split(' ')[0]);
                            
                            infoText.text(`${totalItens} total | ${porcentagemAPI}% concluído`);
                            
                            const progressBar = listaCard.find('.progress-bar');
                            progressBar.css('width', porcentagemAPI + '%');
                            progressBar.attr('aria-valuenow', porcentagemAPI);
                        }
                    }
                    
                    // Atualizar contadores de prioridade se disponíveis na resposta
                    if (response.item && response.item.lista) {
                        const lista = response.item.lista;
                        if (lista.itens_alta_prioridade !== undefined) {
                            atualizarContadorPrioridade(listaCard, 'alta', lista.itens_alta_prioridade, 'Itens de prioridade alta', 'fa-arrow-up', 'text-danger');
                        }
                        if (lista.itens_media_prioridade !== undefined) {
                            atualizarContadorPrioridade(listaCard, 'media', lista.itens_media_prioridade, 'Itens de prioridade média', 'fa-equals', 'text-warning');
                        }
                        if (lista.itens_baixa_prioridade !== undefined) {
                            atualizarContadorPrioridade(listaCard, 'baixa', lista.itens_baixa_prioridade, 'Itens de prioridade baixa', 'fa-arrow-down', 'text-success');
                        }
                    }
                    
                    // Atualizar o status da lista se necessário
                    const listaStatus = response.item?.lista?.status;
                    const listaStatusDisplay = response.item?.lista?.status_display;
                    
                    if (listaStatus) {
                        // Remover as classes de status antigas
                        listaCard.removeClass('em_andamento concluida pausada arquivada');
                        
                        // Adicionar a nova classe de status
                        listaCard.addClass(listaStatus);
                        
                        // Atualizar o badge de status
                        const statusBadge = listaCard.find('.badge-status.em_andamento, .badge-status.concluida, .badge-status.pausada, .badge-status.arquivada');
                        statusBadge.removeClass('em_andamento concluida pausada arquivada');
                        statusBadge.addClass(listaStatus);
                        
                        if (listaStatusDisplay) {
                            statusBadge.text(listaStatusDisplay);
                        }
                        
                        // Adicionar classe de animação se a lista foi concluída
                        if (listaStatus === 'concluida' && !listaCard.hasClass('animation-played')) {
                            listaCard.addClass('animation-played');
                            listaCard.find('.progress-bar').addClass('progress-bar-animated bg-success');
                            setTimeout(function() {
                                listaCard.find('.progress-bar').removeClass('progress-bar-animated');
                            }, 2000);
                            
                            // Atualizar o dashboard localmente
                            atualizarDashboardStatsLocalmente();
                        }
                    }
                },
                error: function(error) {
                    console.error('DEBUG: Erro ao atualizar status via swipe', error);
                    
                    // Reverter UI em caso de erro
                    checkbox.prop('checked', !concluido);
                    
                    if (concluido) {
                        item.removeClass('concluido');
                    } else {
                        item.addClass('concluido');
                    }
                    
                    // Reverter a barra de progresso
                    atualizarProgressoLista(listaCard, !concluido, itemId);
                    
                    // Mostrar erro
                    showMessage('danger', 'Erro ao atualizar item.', true);
                }
            });
        }, 300);
    }
    // Função para formatar a data no formato correto para o backend
    function formatarDataParaBackend(dataString) {
        if (!dataString) return null;
        
        // Se já for uma data no formato ISO, retorna como está
        if (dataString.match(/^\d{4}-\d{2}-\d{2}$/)) {
            return dataString;
        }
        
        try {
            // Converte para objeto Date e formata como YYYY-MM-DD
            const data = new Date(dataString);
            if (isNaN(data.getTime())) {
                return null; // Data inválida
            }
            return data.toISOString().split('T')[0];
        } catch (e) {
            console.error("Erro ao formatar data:", e);
            return null;
        }
    }
    
    /**
     * Handlers para elementos da UI
     */
    
    // Handler para o botão de remover item
    $(document).on('click', '.btn-remove-item', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const itemId = $(this).data('item-id');
        const itemElement = $(this).closest('.lista-item');
        const itemNome = itemElement.find('.item-nome').text().trim();
        
        // Confirmar antes de remover
        if (confirm(`Tem certeza que deseja remover o item "${itemNome}"?`)) {
            removerItem(itemId, itemElement);
        }
    });
    
    // Remover todos os handlers anteriores para evitar duplicação
    $('.item-checkbox').off('change');
    
    // Adicionar o novo handler para checkbox
    $('.item-checkbox').on('change', function() {
        const itemId = $(this).data('item-id');
        const concluido = $(this).prop('checked');
        const novoStatus = concluido ? 'concluido' : 'pendente';
        const itemElement = $(this).closest('.lista-item');
        const listaCard = itemElement.closest('.lista-card');
        
        // Feedback visual imediato
        if (concluido) {
            itemElement.addClass('concluido');
        } else {
            itemElement.removeClass('concluido');
        }
        
        // Atualizar barra de progresso imediatamente para feedback visual
        const novaPortcentagem = atualizarProgressoLista(listaCard, concluido, itemId);
        
        // Enviar para a API
        $.ajax({
            url: `/api/itens/${itemId}/status/`,
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ status: novoStatus }),
            beforeSend: function(xhr) {
                xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
            },
            success: function(response) {
                // A barra já foi atualizada para feedback visual rápido.
                // Se a API retornou uma porcentagem diferente, ajustamos
                if (response.item && response.item.lista && response.item.lista.porcentagem_concluida !== undefined) {
                    const porcentagemAPI = response.item.lista.porcentagem_concluida;
                    if (porcentagemAPI !== novaPortcentagem) {
                        // Obter a contagem de itens atual da interface
                        const infoText = listaCard.find('.text-muted.small');
                        const textoAtual = infoText.text();
                        const totalItens = parseInt(textoAtual.split('|')[0].trim().split(' ')[0]);
                        
                        // Atualizar texto
                        listaCard.find('.text-muted.small').text(
                            `${totalItens} total | ${porcentagemAPI}% concluído`
                        );
                        
                        // Atualizar barra
                        listaCard.find('.progress-bar').css('width', porcentagemAPI + '%');
                        listaCard.find('.progress-bar').attr('aria-valuenow', porcentagemAPI);
                    }
                }
                
                // Atualizar contadores de prioridade se disponíveis na resposta
                if (response.item && response.item.lista) {
                    const lista = response.item.lista;
                    if (lista.itens_alta_prioridade !== undefined) {
                        atualizarContadorPrioridade(listaCard, 'alta', lista.itens_alta_prioridade, 'Itens de prioridade alta', 'fa-arrow-up', 'text-danger');
                    }
                    if (lista.itens_media_prioridade !== undefined) {
                        atualizarContadorPrioridade(listaCard, 'media', lista.itens_media_prioridade, 'Itens de prioridade média', 'fa-equals', 'text-warning');
                    }
                    if (lista.itens_baixa_prioridade !== undefined) {
                        atualizarContadorPrioridade(listaCard, 'baixa', lista.itens_baixa_prioridade, 'Itens de prioridade baixa', 'fa-arrow-down', 'text-success');
                    }
                }
                
                // Atualizar o status da lista se necessário
                const listaStatus = response.item?.lista?.status;
                const listaStatusDisplay = response.item?.lista?.status_display;
                
                if (listaStatus) {
                    // Remover as classes de status antigas
                    listaCard.removeClass('em_andamento concluida pausada arquivada');
                    
                    // Adicionar a nova classe de status
                    listaCard.addClass(listaStatus);
                    
                    // Atualizar o badge de status
                    const statusBadge = listaCard.find('.badge-status.em_andamento, .badge-status.concluida, .badge-status.pausada, .badge-status.arquivada');
                    statusBadge.removeClass('em_andamento concluida pausada arquivada');
                    statusBadge.addClass(listaStatus);
                    
                    if (listaStatusDisplay) {
                        statusBadge.text(listaStatusDisplay);
                    }
                    
                    // Adicionar classe de animação se a lista foi concluída
                    if (listaStatus === 'concluida' && !listaCard.hasClass('animation-played')) {
                        listaCard.addClass('animation-played');
                        listaCard.find('.progress-bar').addClass('progress-bar-animated bg-success');
                        setTimeout(function() {
                            listaCard.find('.progress-bar').removeClass('progress-bar-animated');
                        }, 2000);
                        
                        // Atualizar o dashboard de manera interna
                        atualizarDashboardStatsLocalmente();
                    }
                }
                
                // Mostrar mensagem de sucesso discretamente
                showMessage('success', 'Item atualizado!', true);
            },
            error: function(error) {
                console.error('DEBUG: Erro API', error);
                
                // Em caso de erro, reverter UI
                itemElement.find('.item-checkbox').prop('checked', !concluido);
                if (concluido) {
                    itemElement.removeClass('concluido');
                } else {
                    itemElement.addClass('concluido');
                }
                
                // Reverter a barra de progresso
                atualizarProgressoLista(listaCard, !concluido, itemId);
                
                // Mostrar erro
                showMessage('danger', 'Erro ao atualizar status do item.', true);
            }
        });
    });
    
    // Ver lista completa
    $('.view-lista').on('click', function(e) {
        e.preventDefault();
        const listaId = $(this).data('lista-id');
        // Redirecionar para a página da lista
        window.location.href = `/listas/${listaId}/`;
    });
    

    
    // Excluir lista
    $('.delete-lista').on('click', function(e) {
        e.preventDefault();
        const listaId = $(this).data('lista-id');
        
        if (confirm('Tem certeza que deseja excluir esta lista? Esta ação não pode ser desfeita.')) {
            $.ajax({
                url: `/api/listas/${listaId}/excluir/`,
                type: 'POST',
                beforeSend: function(xhr) {
                    xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
                },
                success: function(response) {
                    showMessage('success', 'Lista excluída com sucesso!');
                    // Remover a lista da interface
                    $(`[data-lista-id="${listaId}"]`).closest('.lista-card').fadeOut(300, function() {
                        $(this).remove();
                        
                        // Se não houver mais listas, mostrar o estado vazio
                        if ($('.lista-card').length === 0) {
                            location.reload();
                        } else {
                            // Atualizar o dashboard
                            atualizarDashboardStatsLocalmente();
                        }
                    });
                },
                error: function(error) {
                    console.error('DEBUG: Erro ao excluir lista', error);
                    showMessage('danger', 'Erro ao excluir lista. Tente novamente.');
                }
            });
        }
    });
    
    // Adicionar item à lista
    $('.add-item').on('click', function(e) {
        e.preventDefault();
        const listaId = $(this).data('lista-id');
        const listaNome = $(this).closest('.lista-card').find('.lista-title').text().trim();
        
        // Preencher o ID da lista no formulário e atualizar o título do modal
        $('#id_item_lista').val(listaId);
        $('#modalNovoItemLabel').html(`<i class="fas fa-plus-circle me-2"></i>Novo Item em "${listaNome}"`);
        
        // Resetar o formulário
        $('#formNovoItem').trigger('reset');
        
        // Mostrar o modal
        $('#modalNovoItem').modal('show');
    });



    // Manipulação do menu de opções de lista
    $(document).on('click', '.lista-more-actions', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Fechar todos os outros menus abertos
        $('.lista-action-menu.show').not($(this).closest('.lista-card').find('.lista-action-menu')).removeClass('show');
        
        // Alternar o menu atual
        $(this).closest('.lista-card').find('.lista-action-menu').toggleClass('show');
    });

    // Fechar menu ao clicar fora
    $(document).on('click', function(e) {
        if (!$(e.target).closest('.lista-more-actions').length && !$(e.target).closest('.lista-action-menu').length) {
            $('.lista-action-menu.show').removeClass('show');
        }
    });

    // Atualização do preview de ícone no modal de edição
    $(document).on('change', '#editar_lista_icone', function() {
        // Remove todas as classes de ícone
        $('#editarIconPreview').removeClass();
        // Adiciona a classe selecionada
        $('#editarIconPreview').addClass($(this).val());
    });

    // Implementar edição de lista
    $(document).on('click', '.edit-lista', function(e) {
        e.preventDefault();
        
        // Fechar menu de opções
        $('.lista-action-menu.show').removeClass('show');
        
        const listaId = $(this).data('lista-id');
        const listaCard = $(this).closest('.lista-card');
        
        // Limpar erros anteriores
        $('#formEditarLista .invalid-feedback').empty();
        $('#formEditarLista .is-invalid').removeClass('is-invalid');
        
        // Preencher o formulário com os dados atuais da lista
        $('#editar_lista_id').val(listaId);
        $('#editar_lista_nome').val(listaCard.find('.lista-title').text().trim());
        $('#editar_lista_objetivo').val(listaCard.find('.lista-objetivo').text().trim());
        
        // Status atual
        const statusAtual = listaCard.attr('class').split(' ').find(cls => 
            ['pendente', 'em_andamento', 'concluida', 'pausada', 'arquivada'].includes(cls)
        );
        $('#editar_lista_status').val(statusAtual);
        
        // Tentar obter a data objetivo se existir
        let dataObjetivo = '';
        const diasRestantesText = listaCard.find('.lista-meta span:contains("dias restantes")').text();
        if (diasRestantesText || listaCard.find('.lista-meta span:contains("Vence hoje")').length) {
            // Se não consigo extrair a data exata, deixo em branco - será tratado pelo backend
            dataObjetivo = '';
        }
        $('#editar_lista_data_objetivo').val(dataObjetivo);
        
        // Obter o ícone atual
        const iconeClass = listaCard.find('.lista-icon i').attr('class');
        $('#editar_lista_icone').val(iconeClass);
        $('#editarIconPreview').removeClass().addClass(iconeClass);
        
        // Obter cor atual se disponível, ou usar a cor padrão
        let corAtual = '#F9A27B'; // Cor padrão
        if (listaCard.data('cor')) {
            corAtual = listaCard.data('cor');
        }
        $('#editar_lista_cor').val(corAtual);
        
        // Abrir o modal
        const editarListaModal = new bootstrap.Modal(document.getElementById('modalEditarLista'));
        editarListaModal.show();
    });

    // Handler para o formulário de edição de lista
    $('#formEditarLista').on('submit', function(e) {
        e.preventDefault();
        
        const listaId = $('#editar_lista_id').val();
        
        // Obter dados do formulário
        const formData = {
            nome: $('#editar_lista_nome').val(),
            objetivo: $('#editar_lista_objetivo').val(),
            status: $('#editar_lista_status').val(),
            data_objetivo: $('#editar_lista_data_objetivo').val(),
            icone: $('#editar_lista_icone').val(),
            cor: $('#editar_lista_cor').val()
        };
        
        // Validar campos obrigatórios
        let hasError = false;
        
        if (!formData.nome) {
            $('#editar_lista_nome').addClass('is-invalid');
            $('#editar_lista_nome').next('.invalid-feedback').text('O nome da lista é obrigatório.');
            hasError = true;
        }
        
        if (hasError) return;
        
        // Enviar para a API
        $.ajax({
            url: `/api/listas/${listaId}/atualizar/`,
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify(formData),
            beforeSend: function(xhr) {
                xhr.setRequestHeader('X-CSRFToken', $('input[name="csrfmiddlewaretoken"]').val());
            },
            success: function(response) {
                // Fechar o modal
                bootstrap.Modal.getInstance(document.getElementById('modalEditarLista')).hide();
                
                // Atualizar a lista na interface
                const listaCard = $(`.lista-card:has([data-lista-id="${listaId}"])`);
                
                // Atualizar título e objetivo
                listaCard.find('.lista-title').text(formData.nome);
                
                if (formData.objetivo) {
                    if (listaCard.find('.lista-objetivo').length) {
                        listaCard.find('.lista-objetivo').text(formData.objetivo);
                    } else {
                        listaCard.find('.lista-title').after(`<p class="lista-objetivo">${formData.objetivo}</p>`);
                    }
                } else {
                    listaCard.find('.lista-objetivo').remove();
                }
                if (formData.cor) {
                    listaCard.data('cor', formData.cor);
                    
                    // Aplicar a nova cor
                    aplicarCorPersonalizada(listaCard);
                }
                
                // Atualizar ícone
                listaCard.find('.lista-icon i').attr('class', formData.icone);
                
                // Atualizar status
                listaCard.removeClass('pendente em_andamento concluida pausada arquivada');
                listaCard.addClass(formData.status);
                
                const statusBadge = listaCard.find('.badge-status');
                statusBadge.removeClass('pendente em_andamento concluida pausada arquivada');
                statusBadge.addClass(formData.status);
                statusBadge.text(response.lista.status_display);
                
                // Atualizar cor se aplicável
                if (formData.cor) {
                    listaCard.data('cor', formData.cor);
                    // Aqui podemos aplicar a cor visualmente se necessário
                    // listaCard.find('.lista-icon').css('background-color', formData.cor);
                }
                
                // Exibir mensagem de sucesso
                showMessage('success', 'Lista atualizada com sucesso!', true);
                
                // Atualizar dashboard se necessário
                atualizarDashboardStatsLocalmente();
            },
            error: function(xhr) {
                console.error('DEBUG: Erro ao atualizar lista', xhr);
                
                // Exibir erros de validação
                if (xhr.responseJSON && xhr.responseJSON.errors) {
                    const errors = xhr.responseJSON.errors;
                    
                    // Limpar erros anteriores
                    $('#formEditarLista .invalid-feedback').empty();
                    $('#formEditarLista .is-invalid').removeClass('is-invalid');
                    
                    // Adicionar novas mensagens de erro
                    for (const field in errors) {
                        $(`#editar_lista_${field}`).addClass('is-invalid');
                        $(`#editar_lista_${field}`).next('.invalid-feedback').text(errors[field]);
                    }
                    
                    showMessage('danger', 'Corrija os erros no formulário.', true);
                } else {
                    showMessage('danger', 'Erro ao atualizar a lista. Tente novamente.', true);
                }
            }
        });
    });
    $('.lista-card').each(function() {
        aplicarCorPersonalizada($(this));
    });


    
    // Executar o ajuste para dispositivos móveis na inicialização
    adjustForMobile();
    
    // Executar o ajuste quando a tela for redimensionada
    $(window).on('resize', function() {
        adjustForMobile();
    });
});


</script>